[ASM в Linux для программистов C](https://ru.wikibooks.org/wiki/%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C)

# Регистры

## Общего назначения

Регистры общего назначения (РОН, англ. General Purpose Registers, сокращённо GPR). Размер — 32 бита.

* `%eax`: Accumulator register — аккумулятор, применяется для хранения результатов промежуточных вычислений.
* `%ebx`: Base register — базовый регистр, применяется для хранения адреса (указателя) на некоторый объект в памяти.
* `%ecx`: Counter register — счетчик, его неявно используют некоторые команды для организации циклов (см. loop).
* `%edx`: Data register — регистр данных, используется для хранения результатов промежуточных вычислений и ввода-вывода.

* `%esp`: Stack pointer register — указатель стека. Содержит адрес вершины стека.
* `%ebp`: Base pointer register — указатель базы кадра стека (англ. stack frame). Предназначен для организации произвольного доступа к данным внутри стека.
* `%esi`: Source index register — индекс источника, в цепочечных операциях содержит указатель на текущий элемент-источник.
* `%edi`: Destination index register — индекс приёмника, в цепочечных операциях содержит указатель на текущий элемент-приёмник.

К регистру можно обращаться по частям:

* к младшим 16 битам регистра %eax можно обратиться так: `%ax`
* `%ax` содержит две однобайтовые половинки: `%ah` и `%al`
* `%ebx` -> `%bx` -> `%bh` / `%bl`
* "eax" значит "extended ax": то есть, расширенный, по сравнению с 16битной архитектурой

Сегментные регистры:

* `%cs`: Code segment — описывает текущий сегмент кода.
* `%ds`: Data segment — описывает текущий сегмент данных.
* `%ss`: Stack segment — описывает текущий сегмент стека.
* `%es`: Extra segment — дополнительный сегмент, используется неявно в строковых командах как сегмент-получатель.
* `%fs`: F segment — дополнительный сегментный регистр без специального назначения.
* `%gs`: G segment — дополнительный сегментный регистр без специального назначения.

## Флаги

Регистр флагов: `%eflags`, и его младшие 16 бит, `%flags`:
Содержит информацию о состоянии выполнения программы, о самом микропроцессоре, а также информацию, управляющую работой некоторых команд. Регистр флагов нужно рассматривать как массив битов, за каждым из которых закреплено определённое значение. Регистр флагов напрямую не доступен пользовательским программам; изменение некоторых битов eflags требует привилегий.

* `cf`: carry flag, флаг переноса: 1 — во время арифметической операции был произведён перенос из старшего бита результата; 0 — переноса не было;
* `zf`: zero flag, флаг нуля: 1 — результат последней операции нулевой; 0 — результат последней операции ненулевой;
* `of`: overflow flag, флаг переполнения: 1 — во время арифметической операции произошёл перенос в/из старшего (знакового) бита результата; 0 — переноса не было;
* `df`: direction flag, флаг направления. Указывает направление просмотра в строковых операциях: 1 — направление «назад», от старших адресов к младшим; 0 — направление «вперёд», от младших адресов к старшим.

В общем, через флаги между командами неявно передаётся дополнительная информация, которая не записывается непосредственно в результат вычислений.

Указатель команды `eip` (instruction pointer). Размер — 32 бита. Содержит указатель на следующую команду. Регистр напрямую недоступен, изменяется неявно командами условных и безусловных переходов, вызова и возврата из подпрограмм.

## Стек

В микропроцессоре стек -- это область памяти, у которой определена вершина (на неё указывает %esp). Поместить новый элемент можно только на вершину стека, при этом новый элемент становится вершиной.
Стек растёт в сторону младших адресов. Это значит, что последний записанный в стек элемент будет расположен по адресу младше остальных элементов стека.

* Команда `push`: уменьшает значение `%esp` на размер элемента в байтах (2 или 4), и записывает новый элемент по адресу.
* Команда `pop`: записывает содержимое в регистр, увеличивает `%esp` на размер элемента

## Память

### Порядок байтов

Предположим, что у нас есть число `0x01020304`. Его можно записать в виде байтовой последовательности:

* начиная с младшего байта: 0x04 0x03 0x02 0x01	— little-endian (Интеловский, x86)
* начиная со старшего байта: 0x01 0x02 0x03 0x04	— big-endian

У порядка little-endian есть одно важное достоинство. Посмотрите на запись числа `0x00000033`:

> 0x33 0x00 0x00 0x00

Если прочесть его как двухбайтовое значение, получим `0x0033`.
Если прочесть как однобайтовое, получим `0x33`. При записи этот трюк тоже работает.

