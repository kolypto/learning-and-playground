# Команды и операнды

У команды может быть до 3х операндов:

* Конкретное значение начинается с `$`: `$0xF1`, `$10`, `$hello_str`. Эти операнды команды называются непосредственными.
* Название регистра начинается с `%`: `%eax`, `%bx`, `%cl`
* Указатель на ячейку памяти
* Неявный операнд: не записываются в коде, но просто сама команда всегда обращается к определённому регистру

Внимание! Если вы забудете знак $, когда записываете непосредственное числовое значение, компилятор будет интерпретировать число как абсолютный адрес. 

Например, команда `movl` копирует источник в назначение:

```s
movl $4, %eax  # поместить номер системного вызова 4=write в регистр eax
```

Суффикс `l` указывает на размер: `b` byte (1), `w` word (2), `l` long (4), `q` quad (8).

Особенность: все команды не умеют работать с двумя операндами в памяти! 
Хотя бы один из них должен быть сначала загружен в регистр.

# Адрес памяти

Как формируется указатель на ячейку памяти? Синтаксис:

> смещение(база, индекс, множитель) = база + индекс × множитель + смещение

Например:

* `(%ecx)`: адрес операнда в регистре. Например, указатель на число или на строку.
* `4(%ecx)`: адрес равен `%ecx + 4`. Например: адресовать отдельные поля структур.
* `-4(%ecx)`: адрес равен `%ecx + 4`
* `foo(,%ecx,4)`: адрес равен `foo + %ecx*4`. Например: обращение к элементам массива, где `%ecx` -- номер элемента, а `foo` - указатель на массив

# Секция кода

Важный нюанс: команды нужно помещать в секцию кода `.text`. Вот так:

```s
.text
        movl    $42, %eax
        ...
```

# Данные

Существуют директивы ассемблера, которые размещают в памяти данные, определенные программистом. 
Аргументы этих директив — список выражений, разделенных запятыми.

* `.byte` — размещает каждое выражение как 1 байт;
* `.short` — 2 байта;
* `.long` — 4 байта;
* `.quad` — 8 байт.

Например:

```s
.byte   0x10, 0xf5, 0x42, 0x55
.long   0xaabbaabb
.short  -123, 456
```

Также существуют директивы для размещения в памяти строковых литералов:

* `.ascii "STR"` размещает строку STR. Нулевых байтов не добавляет.
* `.string "STR"` размещает строку STR, после которой следует нулевой байт (как в языке Си).
* `.asciz "STR"`: синоним `.string`

Данные нужно помещать в секцию данных:

```s
.data
        .string "Hello, world\n"
```

Для неизменяемых данных (констант) есть специальная секция:

```
.section .rodata
        .string "program version 0.314"
```

Архитектура рекомендует, но не требует выравнивания: доступ к невыровненным данным может быть медленнее, но принципиальной разницы нет и ошибки это не вызовет.
Для соблюдения выравнивания в распоряжении программиста есть директива .p2align: Директива .p2align выравнивает текущий адрес до заданной границы:

>  .p2align степень_двойки[[, заполнитель], максимум]

Например:

```s
.data
        .string "Hello, world\n"    /* мы вряд ли захотим считать,
                                       сколько символов занимает эта 
                                       строка, и является ли следующий
                                       адрес выровненным            */
        .p2align 2                  /* выравниваем по границе 4 байта 
                                       для следующего .long         */
        .long 123456
```

# Метки

Метка — это просто константа, значение которой — адрес:

```s
hello_str:
        .string "Hello, world!\n"
```

Существует специальная псевдометка, указывающая на текущий адрес: `.` (точка).


# Объекты

Сделаем так, чтобы `gcc` скомпилировал объектный файл, а потом через `nm` посмотрим список символов в объектном файле:

```console
$ gcc -no-pie -c 01-helloworld.s -o 01-helloworld.o 
$ nm 01-helloworld.o 
00000000 d hello_str
0000000e a hello_str_length
00000000 T main
```

Видим что `hello_str` имеет тип `d` (находится в секции данных), а `hello_str_length` -- абсолютное значение (`a`) и равно `0xE`.
Глобальный символ `main` доступен другим модулям (поэтому он заглавный):

```s
.global main
```

Для создания нового символа используется директива `.set`:

```s
.set foo, 42

# Определяем символ: будет содержать адрес строки                          
hello_str:    
        .string "Hello, world!\n"
# Определяем новый символ, равный арифметическому выражению: из текущего адреса вычитаем адрес 
# начала строки, и ещё один (завершающий ноль), и получаем её длину в байтах. 
        .set    hello_str_length, . - hello_str - 1 
```

# Выделение памяти

Специальная секция `.bss` не занимает места в скомпилированной программе — но при загрузке программы выделится секция памяти, заполненная нулями:

```s
.space sz_in_bytes[, filler]

.bss

# 4 bytes, long
long_var_1:  
        .space 4
 
# Some buffer, 1024 bytes
buffer:  
        .space 1024

# Some structure, 20 bytes
struct:  
        .space 20
```

# Методы Адресации

Эффективность выбранных методов адресации во многом определяет эффективность работы всего процессора в целом.

Прямая, или абсолютная, адресация: адрес записан в оперативной памяти по адресу метки:

```s
.data
num:
        .long 0x1234567

.text
main:
        # Записать значение по адресу (num) в %eax
        movl (num), %eax
        # Сложить с регистром значение по адресу (num)
        addl (num), %eax
```

Непосредственная адресация: самый быстрый метод, но создаёт зависимость кодов команд от данных:

```s
.text
main:
        movl $0x12345, %eax
```

Косвенная (базовая) адресация: указывает адрес ячейки памяти или регистр, в котором содержится адрес операнда.
Это требует время для чтения адреса, но существенно повышает гибкость программирования.
Изменяя содержимое ячейки памяти или регистра, через которые осуществляется адресация, можно, не меняя команды в программе, обрабатывать операнды, хранящиеся по разным адресам. 

```s
.data
num:
        .long 0x1234

.text
.main:
        # Записать адрес метки в регистр ebx
        movl $num, %ebx
        # Записать в %eax значение, прочитанное из оперативной памяти по адресу %ebx
        movl (%ebx), %eax
```

Регистровая адресация: операнд находится во внутреннем регистре процессора:

```s
.data
main:
        # Записать в %eax константу
        movl $0x12345, %eax
        # Записать в %ecx значение из %eax
        movl %eax, %ecx
```

Относительная адресация: 

> Операнд = (база + смещение)

Для задания базового адреса и смещения могут применяться ранее рассмотренные способы адресации. Как правило, базовый адрес находится в одном из регистров регистровой памяти, а смещение может быть задано в самой команде или регистре.

Главный недостаток относительной адресации – большое время вычисления физического адреса операнда. Но существенное преимущество этого способа адресации заключается в возможности создания "перемещаемых" программ – программ, которые можно размещать в различных частях памяти без изменения команд программы. 
В этих случаях достаточно изменить содержимое базового адреса начала команд программы или массива данных, а не модифицировать сами команды.
