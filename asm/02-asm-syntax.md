# Команды и операнды

У команды может быть до 3х операндов:

* Конкретное значение начинается с `$`: `$0xF1`, `$10`, `$hello_str`. Эти операнды команды называются непосредственными.
* Название регистра начинается с `%`: `%eax`, `%bx`, `%cl`
* Указатель на ячейку памяти
* Неявный операнд: не записываются в коде, но просто сама команда всегда обращается к определённому регистру

Внимание! Если вы забудете знак $, когда записываете непосредственное числовое значение, компилятор будет интерпретировать число как абсолютный адрес. 

Например, команда `movl` копирует источник в назначение:

```s
movl $4, %eax  # поместить номер системного вызова 4=write в регистр eax
```

Суффикс `l` указывает на размер: `b` byte (1), `w` word (2), `l` long (4), `q` quad (8).

Особенность: все команды не умеют работать с двумя операндами в памяти! 
Хотя бы один из них должен быть сначала загружен в регистр.

# Адрес памяти

Как формируется указатель на ячейку памяти? Синтаксис:

> смещение(база, индекс, множитель) = база + индекс × множитель + смещение

Например:

* `(%ecx)`: адрес операнда в регистре. Например, указатель на число или на строку.
* `4(%ecx)`: адрес равен `%ecx + 4`. Например: адресовать отдельные поля структур.
* `-4(%ecx)`: адрес равен `%ecx + 4`
* `foo(,%ecx,4)`: адрес равен `foo + %ecx*4`. Например: обращение к элементам массива, где `%ecx` -- номер элемента, а `foo` - указатель на массив

# Секция кода

Важный нюанс: команды нужно помещать в секцию кода `.text`. Вот так:

```s
.text
        movl    $42, %eax
        ...
```

# Данные

Существуют директивы ассемблера, которые размещают в памяти данные, определенные программистом. 
Аргументы этих директив — список выражений, разделенных запятыми.

* `.byte` — размещает каждое выражение как 1 байт;
* `.short` — 2 байта;
* `.long` — 4 байта;
* `.quad` — 8 байт.

Например:

```s
.byte   0x10, 0xf5, 0x42, 0x55
.long   0xaabbaabb
.short  -123, 456
```